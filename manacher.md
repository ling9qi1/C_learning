# C_learning

# manacher's algorithm

### 俗称“马拉车算法”

题目链接：https://www.lanqiao.cn/problems/5003/learning/

思路来源：[ExRoc](https://blog.csdn.net/CSDNjiangshan/article/details/144638971?sharetype=blog&shareId=144638971&sharerefer=APP&sharesource=csdnjiangshan&sharefrom=qq)

一旦你意识到这是寻找最长回文子串的问题，思路一下子就清晰了。最后用 $(y - x / 2)$ 即可求出最后答案。虽说本篇是主要介绍 $manacher's algorithm$,但还是想先介绍本人的时间复杂度为$O(n^2)$的 $brute force$思路，(~~毕竟不能白做了嘛~~)。

```c++
#include<iostream>
#include<algorithm>
#include<cstdio>
typedef long long LL;
using namespace std;
#include <stdio.h>
#include <string.h>
char a[1000005];
int count_1;
int max_1;
int a_len;
int sum_1;
int main(){
    scanf("%s",a);
    a_len = strlen(a);
    for(int i = 0; i < a_len; i++){
        if(a[i] == '1'){
            sum_1++;
        }
        if(a[i] == '1' || a[i] == '0'){
            for(int j = i + 1, k = i; j < a_len, k >= 0; k--, j++){
                if(a[k] == a[j]){
                    if(a[k] == '1'){
                        count_1++;
                    }
                }
                else{
                    break;
                }
            }
            if(count_1 > max_1){
                max_1 = count_1;
            }
            count_1 = 0;
        }
        if(a[i] == '0'){
            for(int j = i + 1, k = i - 1; j < a_len, k >= 0; j++, k--){
                if(a[j] == a[k]){
                    if(a[j] == '1'){
                        count_1++;
                    }
                }
                else{
                    break;
                }
            }
            if(count_1 > max_1){
                max_1 = count_1;
            }
            count_1 = 0;
        }
    }
    printf("%d\n",sum_1 - max_1);

    return 0;
}
```

#### 大致思路

现在的问题是，如何寻找最长回文子串。同时找出最长回文子串中$1$的个数。

- 先遍历，看是$0$还是$1$，若为$0$，他可以作为奇数串的中心，内层遍历方法为`for(int j = i + 1, k = i - 1; j < a_len, k >= 0; j++, k--)`；也可以作为偶数串的“中心”，内层遍历方法为`for(int j = i + 1, k = i; j < a_len, k >= 0; k--, j++)`。若为$1$，他只能作为偶数串的“中心”，内层遍历方法为`for(int j = i + 1, k = i; j < a_len, k >= 0; k--, j++)`。
- 然后判断`a[j]`与`a[k]`是否相等，若相等，进一步判断是否等于$1$，若是，则`count_1++`。若不相等，则`break`。注意，不能将这两步的$if$判断语句合并，因为如果`a[j] == a[k]`但都等于$0$，则`count_1`不需要加$1$,但得继续循环并判断下去，而不能`break`直接跳出此次判断。
- 最后，找`count_1`的最大值，即找到了$1$所能出现次数的最小值。

---

好了，接下来，得好好聊聊$manacher's$ $algorithm$了。

推荐视频：[董晓算法](https://www.bilibili.com/video/BV173411V7Ai/?spm_id_from=333.999.0.0&vd_source=607514df4428a309d5130d87a0423d0c)

~~这老师讲是讲的无聊了点儿，~~ 但绝对是我找了这么多资料后，讲的最清楚的，没有之一。废话少说，开始正文。

- 再开始前，先看一个式子：**奇 + 偶 = 奇**
这个式子有非常神奇的作用，对于奇数个回文串，按中心展开即可，那如果是偶数个呢？
那就想办法把它变成奇数个，比如`abab`，我们可以把它变成`#a#b#a#b#`，这样，它就变成了奇数个回文串，按中心展开即可。如果是奇数个回文串，比如`aba`，我们可以把它变成`#a#b#a#`，这样，它也变成了奇数个回文串，按中心展开即可。所以，根据最开始的那个式子，我们可以把所有回文串都变成奇数个回文串，这样，我们就可以统一处理了。为什么要用`#`呢，因为在字符串中几乎是不可能出现`#`的，可以避免与原字符串冲突。

- 第二个前提提要：举例，对于`babab`以`b`为中心的回文串，加入`#`后，变为`#b#a#b#a#b#`仍是以`b`为中心的回文串，并且，你以`b`为中心，无论是往左数(`#a#b#`)，还是往右数(`#a#b#`)，从`b`开始数，不包括`b`,皆是五个字符，恰好等于原回文串的长度。对于偶数个`abba`，加入`#`后，变为`#a#b#b#a#`以中心的`#`展开，无论是往左数(`b#a#`)，还是往右数(`b#a#`)，皆是四个字符，也等于原回文子串长度，神奇吧（本人现在还说不上来原因，所以，没法儿解释）。

- 第三个前提提要：该如何插入字符`#`呢？
对了，忘说了，首先要在字符串前加上`$`，这样就不用考虑下限问题，因为没有字符会与`$`相同，所以到时候暴力遍历到这儿会自动停止。

代码：
```c#
void change(char *a)
{
    int n = strlen(a);
    char s[MAX];
    s[0] = '$';
    int k = 0;
    s[++k] = '#';
    for(int i = 0; i < n; i++){
        s[++k] = a[i];
        s[++k] = '#';
    }
    n = k;
}
```

- 然后，开始思路风暴，仍是举例说明：
![alt text](<屏幕截图 2024-12-26 232446.png>)

别着急，马上说明这个图的含义，$i$是指各个字符的位置，$s$不用解释了吧，$d[i]$是回文串半径，准确来说是回文串半径减一，我不想使用真正的回文串半径是因为，此时的$d[i]$数值恰好等于以第$i$个字符为中心的回文串长度。先是暴力遍历，到了以$b$为中心的位置$6$，观察，位置$7$处于以位置$6$为中心的圈中，位置$7$的字符关于位置$6$对称，对称到位置$5$处，回文串长度也同样对称，则$d[7] = d[5] = 0$；同理，位置$8$的字符关于位置$6$对称，对称到位置$4$处，则$d[8] = d[4] = 1$；但我们发现，位置$9$与位置$3$关于$6$对称，但$d[3] = 2$，$d[9] = 0$，$d[9] \neq d[3]$ ，这便是我觉得最有意思的部分。为了他，值得另起下文。

- 首先，令 $l = 3, r = 9$ ，$l$ 是指圈的左边界，$r$ 是指圈的右边界。$i$ 关于对称中心$6$的对应点是 $r - i + l$。之前可以利用回文串自身的对称性来快速找到 $d[i]$，是因为 $(r - i) > d[r - i + l]$。而对于 $9$ 来说，$r - i = 9 - 9 = 0$，$d[r - i + l] = d[3] = 2$，$(r - i) <= d[r - i + l]$，所以，对于 $9$，不能简单的找其对称点来确定 $d[9]$。

画图解释：
![alt text](<屏幕截图 2024-12-26 210215.png>)

**$But$**，我们可以确定的一点是，$i$ 的回文串长度至少为 $(r - i)$，之后，再暴力遍历,找到其最长回文串长度。由此，我们可以先确定 $d[i] = min(d[r - i + l], r - i)$。别担心，这并不是最终的 $d[i]$，要确定最终的 $d[i]$，还得经历一些些磨炼，即暴力遍历。

- 刚才，谈论的是 $i < r$，即 $i$ 在圈内的情况，若 $i$ 在圈外的话，直接 $brute force$。

- 最后，确定 $l$ 和 $r$ 的值：若 $d[i] + i > r$（该式子的含义是 $i$ 处的最右侧回文串字符已经出圈了），则 $l = i - d[i], r = i + d[i]$。不论 $i$ 是在圈内还是在圈外，$l$ 和 $r$ 的值都会被更新。

~~最后，不得不说，贵圈这真乱，我可没有内涵某鱼哦~~~

---

$manacher's algorithm$ 的完整代码：

```c#
#define MAX 1000000 + 100
char a[MAX];
char s[MAX];
char d[MAX];
char str[MAX];
int k, l, maxn, r = 1;
int manacher(char *a)
{
    int n = strlen(a);
    s[0] = '$', s[++k] = '#';
    for(int i = 0; i < n; i++){
        s[++k] = a[i];
        s[++k] = '#';
    }
    n = k;

    for(int i = 2; i <= n; i++){
        if(i <= r){
            d[i] = min(d[r - i + l],r - i);
        }
        while(s[i - d[i] - 1] == s[i + d[i] + 1]){
            d[i]++;
        }
        if(i + d[i] > r){
            l = i - d[i];
            r = i + d[i];
        }
        if(d[i] > maxn){
            maxn = d[i];
        }
    }
    return maxn;
}
```

对于其中的细节，只能举例子来说：
$eg.$ 请找出字符串 $aabb$ 的最长回文子串长度。（我把题出得简单了一点，免得互相折磨。）

首先，加入\# 和 \$，变为 \$#a#a#b#b#a#a#，不行，必须得画个图示意一下。
![alt text](<屏幕截图 2024-12-26 215740.png>)

- 现在处于即将进入 $for$循环的状态，$d[0]$ 和 $d[1]$ 毫无疑问，都是 $0$。在最开始，$r = 0 \ or\  r = 1$ 都行，只要是小于$2$ 就行，这是为了防止之后对判断是否 $i + d[i] > r$ 产生干扰，而因为此时 $r$ 还没有意义，$l$ 也没有意义，所以，$l = 0$。

- 此时，$i = 2 $，$ i = 1$ ，不满足 $if(i <= r)$，所以，进入到 $while$循环，$s[2 - 0 - 1] = s[2 + 0 + 1] = 0$，$d[2]++$，$d[2] = 1$，$s[2 - 1 - 1] \neq s[2 + 1 + 1]$，跳出 $while$循环，$i + d[i] = 3$，$r = 2$，满足$(i + d[i] > r)$，更新 $l$ 和 $r$，$l = 2 - 1 = 1$，$r = 2 + 1 = 3$。形成了以 $2$ 为中心的回文串，如图。
![alt text](<屏幕截图 2024-12-26 221626.png>)

- 接下来，$i = 3$，$r = 3$，满足 $i <= r$，在圈中，$d[r - i + l] = d[3 - 3 + 1] = 0$，$r - i = 3 - 3 = 0$，所以，$d[i] = min(d[r - i + l],r - i) = min(0, 0) = 0$，进入到 $while$循环中，$s[i - d[i] - 1] = s[3 - 0 - 1] = s[2],s[i + d[i] + 1] = s[3 + 0 + 1] = s[4],s[2] == s[4]$，$so$，$d[3]++$，$d[3] = 1$。继续 $while$循环，$s[i - d[i] - 1] = s[3 - 1 - 1] = s[1],s[i + d[i] + 1] = s[3 + 1 + 1] = s[5],s[1] == s[5]$，$so$，$d[3]++$，$d[3] = 2$。又继续 $while$循环，$s[i - d[i] - 1] = s[3 - 2 - 1] = s[0]$，已经不用算了，因为没有字符与 \$ 相同，这就不得不说在最开头设置\$ 的英明之处了。$so$，跳出$while$循环，进入$if(i + d[i] > r)$，$i + d[i] = 3 + 2 = 5$，$r = 3$，满足，更新 $l$ 和 $r$，$l = 3 - 2 = 1$，$r = 3 + 2 = 5$。形成了以 $3$ 为中心的回文串，如图。
![alt text](<屏幕截图 2024-12-26 223236.png>)

妈的，不想写了，后面的自己悟吧。