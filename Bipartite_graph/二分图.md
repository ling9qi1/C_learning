# 二分图(二分染色法)

## 封锁阳光大学

## 题目描述

曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。

阳光大学的校园是一张由 $n$ 个点构成的无向图，$n$ 个点之间由 $m$ 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。

询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。

## 输入格式

第一行两个正整数，表示节点数和边数。
接下来 $m$ 行，每行两个整数 $u,v$，表示点 $u$ 到点 $v$ 之间有道路相连。

## 输出格式

仅一行如果河蟹无法封锁所有道路，则输出 `Impossible`，否则输出一个整数，表示最少需要多少只河蟹。

## 样例 #1

### 样例输入 #1

```
3 3
1 2
1 3
2 3
```

### 样例输出 #1

```
Impossible
```

## 样例 #2

### 样例输入 #2

```
3 2
1 2
2 3
```

### 样例输出 #2

```
1
```

## 提示

【数据规模】   
对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，保证没有重边。


### 分析
对于该问题的思考，可以很自然的联想到二分染色法，即若其可以形成二分图，则输出最小值，若不能，则输出 $Impossiple$ ，现在，先来讲一讲什么是二分图。

#### 二分图
顾名思义，把一堆数字分成两个集合，在同一个集合中的数字都是同一种颜色，之后都简称，黑（B），白（W）。二分图中不可能出现奇数环，只可能有单链或者是偶数环，若有奇数环出现，则怎么样都无法满足相邻的数字染色不同。

而这道题显然是很多个二分图组合在一起，分开求解即可，用dfs深搜。


*判断是否是二分图的代码模版*
```cpp
//创建邻接表
vector<int> g[N];
int n, m, a, b;
void input() {
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);  //无向图，需要一条边正反存两次
    }
}

//dfs深搜，搜索与u相连的的数字，并染上颜色
int color[N];
bool dfs(int u,int c) {
    color[u] = c;
    for (int i = 0; i < g[u].size(); ++i) {
        int v = g[u][i];
        if (color[v] == -1) {
            if (!(dfs(v, !c))) return false;
            else if (color[v] == c) return false;
        }
    }
    return true;
}

//判断是否是二分图
bool check() {
    memset(color, -1, sizeof(color));
    int flag = 0;
    for (int i = 1; i <= n; ++i) {
        if (color[i] == -1) {
            if (!dfs(i, 0)) {
                flag = 1;
                break;
            }
        }
    }
    return flag;
}
```


*AC代码*

```cpp

